# Qeexo AutoML Static Engine Library Application Guide

  Qeexo AutoML Static Engine Library is generated by Automl WebUI, which provides the classify functions that was trained with the data collected by Automl WebUI's Data Collection page, you can easily get this library file from Automl WebUI, and easily apply the Qeexo AutoML classify technology by integrating the static engine library to your embedded project.

  This document is intended as a help to the library integration process.

### Step 1. Get the static engine library package from WebUI

You can download the static engine library package from the  Automl WebUI's Models page, as shown in below picture: 

![](https://github.com/leomonan/listdelsame/blob/master/download_the_static_library_package.jpg?token=AGRW7CKHCT6HMMUYIL6EWVDAUSZWM)

Please click 'save .zip'  to save the static engine library package to your local path, the file will be saved with the name of {board_name}_{algorithm}\_{version}_static.zip,  take STWINKT1B board as example, if you choose the gbm algorithm to train the model, you will get 'STWIN-gbm-1.0-static.zip'. 

By extracting the .zip file, you will get two files:
```
â”œâ”€â”€ libQxClassifyEngine.a 
â”œâ”€â”€ QxAutoMLUser.h
```

#### ðŸ”¹ libQxClassifyEngine.a 
This is the static engine library file that contains the classify interfaces and can be linked to your target device binary in your own project.
           
A few interfaces are needed to be implemented to port the classify function to your project, that part is described in: https://github.com/leomonan/listdelsame/blob/master/QeexoAutoML_Embedded_Application_Guide.md#2-implement-essential-functions-to-fill-sensor-data-and-call-classification-api-from-static-engine-library
    
    
#### ðŸ”¹ QxAutoMLUser.h
This file contains the sensor configurations and API declarations of the static engine library, the content of sensor configurations are automatically generated from customer's sensor configuration in WebUI's data collection page.

This file inclde the following parts:

 ##### Sensor Configuration
 1. Enabled Sensor Types
 
 If the type of sensor(s) is(are) enabled in WebUI, the according sensor macro(s) will be defined in this file, available sensor types are:
```
      QXAUTOMLCONFIG_SENSOR_ENABLE_ACCEL
      QXAUTOMLCONFIG_SENSOR_ENABLE_GYRO
      QXAUTOMLCONFIG_SENSOR_ENABLE_MAG
      QXAUTOMLCONFIG_SENSOR_ENABLE_PRESSURE
      QXAUTOMLCONFIG_SENSOR_ENABLE_PROXIMITY
      QXAUTOMLCONFIG_SENSOR_ENABLE_AMBIENT
      QXAUTOMLCONFIG_SENSOR_ENABLE_HUMIDITY
      QXAUTOMLCONFIG_SENSOR_ENABLE_TEMPERATURE
      QXAUTOMLCONFIG_SENSOR_ENABLE_TEMPERATURE_EXT1
      QXAUTOMLCONFIG_SENSOR_ENABLE_ACCEL_LOWPOWER
      QXAUTOMLCONFIG_SENSOR_ENABLE_ACCEL_HIGHSENSITIVE
      QXAUTOMLCONFIG_SENSOR_ENABLE_MICROPHONE
      QXAUTOMLCONFIG_SENSOR_ENABLE_MICROPHONE_ANALOG
      QXAUTOMLCONFIG_SENSOR_ENABLE_LIGHT
```
 2. FS and ODR of Enabled Sensors
 
 The sensor FS and ODR will be defined in this file if the sensor(s) is(are) enabled.
 
 Example:
 ```
 #ifdef QXAUTOMLCONFIG_SENSOR_ENABLE_ACCEL
 #define QXAUTOMLCONFIG_SENSOR_ACCEL_FSR  2.0f
 #define QXAUTOMLCONFIG_SENSOR_ACCEL_ODR  208.0f
 #endif
```
 3. Enumerations of Sensor Types
 
This type enumerated the sensor type that sensor data comes from.
```
    typedef enum {
      SENSOR_TYPE_NONE = 0, /*!< None defined sensor */
      SENSOR_TYPE_ACCEL, /*!< Default accelerometer sensor */
      SENSOR_TYPE_GYRO, /*!< Default gyroscope sensor */
      SENSOR_TYPE_MAG, /*!< Magnetometer sensor */
      ...
      SENSOR_TYPE_MAX
    }QXOSensorType;
```
##### Classify Interfaces Declaration

The static engine library provided two interfaces for customer, they are:
```
1.void QxFillSensorData(QXOSensorType type, void* data, int data_len);
```
You can call this function to fill the sensor data to static engine library in each ODR circle.
    
```
2. int QxClassify(void); 
```
   You can call this funtion to trigger the classify action in static engine library
   

##### Classify Interval
```
#define PRED_CLASSIFICATION_INTERVAL_IN_MSECS 153
```
   This macro defines the calling interval of `int QxClassify(void)`, '153' indicates `int QxClassify(void)` should be called in each 153 milliseconds



### Step 2. Implement essential functions to fill sensor data and call classification API

The below diagram shows how Qeexo classify interfaces should run in your device: 
![](https://github.com/leomonan/listdelsame/blob/master/QeexoAutomlStaticEngineUserProcess.png?token=AGRW7CKHCT6HMMUYIL6EWVDAUSZWM)
From the diagram we can know, Qeexo static engine library provides two interface: `void QxFillSensorData()` and `void QxClassify()`, customer need to implment a funtion named `int QxAutoMLWork()` that calls these two interfaces to fill sensor data and do classification in periods of time.


ðŸ”¹ 1. `int QxAutoMLWork()` 

`int QxAutoMLWork()` is a function implemented by customer which will run in a thread loop, it calls `void QxFillSensorData()` to fill sensor data to the classify engine in each ODR circle, and call `in QxClassify()` in each PRED_CLASSIFICATION_INTERVAL_IN_MSECS interval which defined in 'QxAutoMLUser.h'


Here is an example of `int QxAutoMLWork()` implementation, in this example, we use 100HZ sensor ODR to fill sensor data, so the data fill interval is 1000/100Hz = 10 ms :

```
#include "QxAutoMLUser.h"
int QxAutoMLWork()
{
    static int time_sum = 0;
    static int result = -1;

    /* 10ms for 100HZ sensor ODR */
    const int work_interval = 10;   

    /* Get current tick in ms */
    int tick = NativeOSGetTick();

    /* Fill sensor data to classify engine */
    NativeFillDataFrame();

    time_sum += work_interval;
    if (time_sum >= PRED_CLASSIFICATION_INTERVAL_IN_MSECS) { 
         /* Call classify periodically each pred_interval */
        result = QxClassify();
        time_sum = 0; 
    }
        
    int diff = NativeOSGetTick() - tick;

    if(diff < work_interval) {
        NativeOSDelay(work_interval - diff);
    }

    return result;
}
```

`Note: if you are using an ODR close to 100HZ that did the data collection (e.g. 104HZ), use 100HZ here is okay, will not effect too much on performance, and if you are using a ODR high than 100HZ, we recommand you to use sensor FIFO mode to fill data, for more details, please refer to: (link)[title]`

ðŸ”¹ `2. void NativeFillDataFrame()`

   Description:
    This function need to be implemented by customer, it calls `void QxFillSensorData()` to fill sensor data which are enabled in 'QxAutoMLUser.h'.
    
An example of its implementation is shown below: (take STWINKT1B board as example)
    
```
#include "QxAutoMLUser.h"
void NativeFillDataFrame(void)
{
   /* Fill Accel data if it is enable in staic engine library */
#ifdef QXAUTOMLCONFIG_SENSOR_ENABLE_ACCEL
    BSP_MOTION_SENSOR_AxesRaw_t Acceleration;
    int32_t status= BSP_MOTION_SENSOR_GetAxesRaw(IIS2DH_0, MOTION_ACCELERO, &Acceleration);
    if (status == BSP_ERROR_NONE) {
        QxFillSensorData(SENSOR_TYPE_ACCEL, &Acceleration, 6);
    }

#endif

/* Fill Gryo data if it is enable in staic engine library */
#ifdef QXAUTOMLCONFIG_SENSOR_ENABLE_GYRO
    BSP_MOTION_SENSOR_AxesRaw_t AngularVelocity;
    status= BSP_MOTION_SENSOR_GetAxesRaw(ISM330DHCX_0, MOTION_GYRO, &AngularVelocity);
    if (status == BSP_ERROR_NONE) {
        QxFillSensorData(SENSOR_TYPE_GYRO, &AngularVelocity, 6);
    }
#endif
}

```
Above function `void QxFillSensorData()`  is provided by 'libQxClassifyEngine.a'
```
    extern void QxFillSensorData(QXOSensorType type, void* data, int data_len);
```
Description: 
  
Fill sensor data to Qeexo classify engine.
      
  Parameters:
  
`QXOSensorType type`:  Sensor type defined in QxAutoMLUser.h
     
` void* data`:  The data buff pointer, for 3-axis sensor data, the data structure is shown as below:
     
![](https://github.com/leomonan/listdelsame/blob/master/3-axis_data_format.jpg?token=AGRW7CKHCT6HMMUYIL6EWVDAUSZWM)
Each axis data takes 2 bytes space, so 3-axis data take 6 bytes space, below is an example of 3-axis data struct declaration:
   ```
   typedef struct
   {
     int16_t x;
     int16_t y;
     int16_t z;
   } BSP_MOTION_SENSOR_AxesRaw_t;
```
   `int data_len`:  The data length of sensor data buffer, here should 6(size of 3-axis sensor data).

3. `void NativelInitSensor(void)`

This function initializes the device sensor driver parameters that are defined in 'QxAutoMLUser.h'

 Here is an example of the implementation of this function, please notice that
`QXAUTOMLCONFIG_SENSOR_ACCEL_ODR`, `QXAUTOMLCONFIG_SENSOR_ACCEL_FSR`, `QXAUTOMLCONFIG_SENSOR_GYRO_ODR` and  `QXAUTOMLCONFIG_SENSOR_GYRO_FSR` are defined in 'QxAutoMLUser.h': 
```
#include "QxAutoMLUser.h"
void NativelInitSensor(void)
{
    static bool senosr_initialized = false;
    if (senosr_initialized) {
        return;
    }
    senosr_initialized = true;
    
    /* init and enable accelerometer @& gyrometer */
#ifdef QXAUTOMLCONFIG_SENSOR_ENABLE_ACCEL
    BSP_MOTION_SENSOR_Init(IIS2DH_0, MOTION_ACCELERO);
    BSP_MOTION_SENSOR_SetOutputDataRate(IIS2DH_0, MOTION_ACCELERO, QXAUTOMLCONFIG_SENSOR_ACCEL_ODR);
    BSP_MOTION_SENSOR_SetFullScale(IIS2DH_0, MOTION_ACCELERO, QXAUTOMLCONFIG_SENSOR_ACCEL_FSR);
    
#endif

#ifdef QXAUTOMLCONFIG_SENSOR_ENABLE_GYRO

    BSP_MOTION_SENSOR_Init(ISM330DHCX_0, MOTION_GYRO);
    BSP_MOTION_SENSOR_SetOutputDataRate(ISM330DHCX_0, MOTION_GYRO, QXAUTOMLCONFIG_SENSOR_GYRO_ODR);
    BSP_MOTION_SENSOR_SetFullScale(ISM330DHCX_0, MOTION_GYRO, QXAUTOMLCONFIG_SENSOR_GYRO_FSR);

#endif
}
```

4. Native OS tick funtions

     `void NativeOSDelay(int msec)`: Provides a tick value in millisecond.
     
     `int NativeOSGetTick()`: Gets tick counter in millisecond unit.



 ### Step 3. Run `int QxAutoMLWork()` in your application
  After finished all of above steps, function `int QxAutoMLWork()` gets ready to run in any thread loop that you want to do the classification. 

You can call the functions like this:
```
void applicatioin_thread_loop()
{
    NativelInitSensor();
    
    while (1){
        int ClassificationResult;

        ClassificationResult = QxAutoMLWork();
        if (ClassificationResult) {
            BSP_LED_On(LED1);
      } else {
            BSP_LED_Off(LED1);
      }
    }
}
```



  Congratulations! The integration of AutoML static engine library is done, now please compile your project to build and link all funstions for classification, if everything goes okay, you should see the classification runs as good as what you see in WebUI's model LIVE test.
  
  Tips:  If you got link error like:
  ```
  undefined reference to `arm_cfft_f32'
```
  Please modify your project's build configuration to add CMSIS arm_cortexM4lf_math library to your target linking.


## Use FIFO mode to fill sesor data in case of ODR higher than 100HZ

![](https://github.com/leomonan/listdelsame/blob/master/QeexoAutomlStaticEngineUserProcessFIFO.png?token=AGRW7CKHCT6HMMUYIL6EWVDAUSZWM)
