# Qeexo AutoML Static Library Application Guide

  Qeexo AutoML Static Library is generated by Automl WebUI, which provides the classify functions that was trained with the data collected by Automl WebUI's Data Collection page, you can easily get this library file from Automl WebUI, and easily apply the Qeexo AutoML classify technology by integrating the static library to your embedded device's binary.

  This document is intended as a help to the integration process.

### 1. Get the static library package from WebUI

You can download the static library package from the  Automl WebUI's Models page, as shown in below picture: 

![](https://github.com/leomonan/listdelsame/blob/master/download_the_static_library_package.jpg?token=AGRW7CKHCT6HMMUYIL6EWVDAUSZWM)

Please click 'save .zip'  to save the static library package to your local path, the file will be saved with the name of {board_name}_{algorithm}\_{version}_static.zip,  take STWINKT1B board as example, if you choose the gbm algorithm to train model, you will get 'STWIN-gbm-1.0-static.zip'. 

By extracting the .zip file, you will get two files:
```
â”œâ”€â”€ libQxClassifyEngine.a 
â”œâ”€â”€ QxAutoMLUser.h
```

##### ðŸ”¹ libQxClassifyEngine.a 
This is the static library file that contains the classify interfaces and can be linked to your target device binary in your own project.
           
A few interfaces are needed to be implemented to port the classify function to your project, that part is described in: ![](https://github.com/leomonan/listdelsame/blob/master/download_the_static_library_package.jpg?token=AGRW7CKHCT6HMMUYIL6EWVDAUSZWM)
    
    
##### ðŸ”¹ QxAutoMLUser.h
This file contains the sensor configurations and API declarations of the static library, the content of configurations are automatical generated by customer's sensor config in WebUI's data collection page.
 ###### Sensor Configuration
 1. Enabled Sensor Types
 
 If the type of sensor is enabled in WebUI, the according sensor macro will be defined in this file, available sensor types are:
```
      QXAUTOMLCONFIG_SENSOR_ENABLE_ACCEL
      QXAUTOMLCONFIG_SENSOR_ENABLE_GYRO
      QXAUTOMLCONFIG_SENSOR_ENABLE_MAG
      QXAUTOMLCONFIG_SENSOR_ENABLE_PRESSURE
      QXAUTOMLCONFIG_SENSOR_ENABLE_PROXIMITY
      QXAUTOMLCONFIG_SENSOR_ENABLE_AMBIENT
      QXAUTOMLCONFIG_SENSOR_ENABLE_HUMIDITY
      QXAUTOMLCONFIG_SENSOR_ENABLE_TEMPERATURE
      QXAUTOMLCONFIG_SENSOR_ENABLE_TEMPERATURE_EXT1
      QXAUTOMLCONFIG_SENSOR_ENABLE_ACCEL_LOWPOWER
      QXAUTOMLCONFIG_SENSOR_ENABLE_ACCEL_HIGHSENSITIVE
      QXAUTOMLCONFIG_SENSOR_ENABLE_MICROPHONE
      QXAUTOMLCONFIG_SENSOR_ENABLE_MICROPHONE_ANALOG
      QXAUTOMLCONFIG_SENSOR_ENABLE_LIGHT
```
 2. Enabled Sensor's FS and ODR
 
 The sensor FS and ODR will be defined in this file if that sensor is enabled  
 ```
 #ifdef QXAUTOMLCONFIG_SENSOR_ENABLE_ACCEL
 #define QXAUTOMLCONFIG_SENSOR_ACCEL_FSR  2.0f
 #define QXAUTOMLCONFIG_SENSOR_ACCEL_ODR  208.0f
 #endif
```
 3. Enumerations of Sensor Types
 
This type enumerated which sensor type the data comes from.
```
    typedef enum {
      SENSOR_TYPE_NONE = 0, /*!< None defined sensor */
      SENSOR_TYPE_ACCEL, /*!< Default accelerometer sensor */
      SENSOR_TYPE_GYRO, /*!< Default gyroscope sensor */
      SENSOR_TYPE_MAG, /*!< Magnetometer sensor */
      ...
      SENSOR_TYPE_MAX
    }QXOSensorType;
```
###### Classify Interfaces Declaration

  There are two interfaces that is provided by the library, they are
```
1.void QxFillSensorData(QXOSensorType type, void* data, int data_len);
```
You can call this function to fill the sensor data to static library in each ODR circle.
    
```
2. int QxClassify(void); 
```
   You can call this funtion to trigger the classify action in static library

3. Classify interval
   This macro defines the calling interval of `int QxClassify(void)`

Example: 
```
#define PRED_CLASSIFICATION_INTERVAL_IN_MSECS 153
```
   '153' indicates `int QxClassify(void)` should be called in each 153 milliseconds

### 2. Implement essential functions to fill sensor data and call classification API from static library

ðŸ”¹ 1. `int QxAutoMLWork()` 
`int QxAutoMLWork()` is a function implemented by customer that should run in a thread loop, it calls `void QxFillSensorData()` to fill sensor data to the classify engine in each ODR circle, and call `in QxClassify()` in each PRED_CLASSIFICATION_INTERVAL_IN_MSECS interval which defined `in QxAutoMLUser.h`

![](https://github.com/leomonan/listdelsame/blob/master/QeexoAutomlStaticEngineUserProcess.png?token=AGRW7CKHCT6HMMUYIL6EWVDAUSZWM)

Here is a example code of `int QxAutoMLWork()`, in this example, we use 100HZ sensor ODR to fill sensor data:

```
#include "QxAutoMLUser.h"
int QxAutoMLWork()
{
    static int time_sum = 0;
    static int result = -1;

    /* 5ms for 100HZ sensor ODR */
    const int work_interval = 5;   

    /* Get current tick in ms */
    int tick = NativeOSGetTick();

    /* Fill sensor data to classify engine */
    NativeFillDataFrame();

    time_sum += work_interval;
    if (time_sum >= PRED_CLASSIFICATION_INTERVAL_IN_MSECS) { 
         /* Call classify periodically each pred_interval */
        result = QxClassify();
        time_sum = 0; 
    }
        
    int diff = NativeOSGetTick() - tick;

    if(diff < work_interval) {
        NativeOSDelay(work_interval - diff);
    }

    return result;
}
```
ðŸ”¹ `2. void NativeFillDataFrame()`
   Description:
    This function need to be implemented by customer, it calls `void QxFillSensorData()` to fill sensor data which are enabled in 'QxAutoMLUser.h'
    An example of its implementation is shown below: (take STWINKT1B board as example)
    
```
#include "QxAutoMLUser.h"
void NativeFillDataFrame(void)
{
   /* Fill Accel data if it is enable in staic engine library */
#ifdef QXAUTOMLCONFIG_SENSOR_ENABLE_ACCEL
    BSP_MOTION_SENSOR_AxesRaw_t Acceleration;
    int32_t status= BSP_MOTION_SENSOR_GetAxesRaw(IIS2DH_0, MOTION_ACCELERO, &Acceleration);
    if (status == BSP_ERROR_NONE) {
        QxFillSensorData(SENSOR_TYPE_ACCEL, &Acceleration, 6);
    }

#endif

/* Fill Gryo data if it is enable in staic engine library */
#ifdef QXAUTOMLCONFIG_SENSOR_ENABLE_GYRO
    BSP_MOTION_SENSOR_AxesRaw_t AngularVelocity;
    status= BSP_MOTION_SENSOR_GetAxesRaw(ISM330DHCX_0, MOTION_GYRO, &AngularVelocity);
    if (status == BSP_ERROR_NONE) {
        QxFillSensorData(SENSOR_TYPE_GYRO, &AngularVelocity, 6);
    }
#endif
}

```
`void QxFillSensorData()`  is provided by `libQxClassifyEngine.a`
```
    extern void QxFillSensorData(QXOSensorType type, void* data, int data_len);
```
  Description: 
      Fill sensor data to Qeexo classify engine.
      
  Parameters:
`QXOSensorType`: Sensor type Enum defined in QxAutoMLUser.h
     
`data` The data buff pointer, for 3-axis sensor data, the data structure is shown as below:
     
     ![](https://github.com/leomonan/listdelsame/blob/master/3-axis_data_format.jpg?token=AGRW7CKHCT6HMMUYIL6EWVDAUSZWM)
Each axis data takes 2 bytes space, 3-axis data take 6 bytes space, below is the example of 3-axis data struct declaration:
   ```
   typedef struct
   {
     int16_t x;
     int16_t y;
     int16_t z;
   } BSP_MOTION_SENSOR_AxesRaw_t;
```
   `int data_len`:  The data length of sensor data buffer, should be the multiple of 6(size of 3-axis sensor data).
    
    
3. `void NativelInitSensor(void)`
This function initializes the device sensor driver parameters that are defined in 'QxAutoMLUser.h'

 Here is an example of the implementation of this function, please notice that QXAUTOMLCONFIG_SENSOR_ACCEL_ODR/QXAUTOMLCONFIG_SENSOR_ACCEL_FSR/QXAUTOMLCONFIG_SENSOR_GYRO_ODR/QXAUTOMLCONFIG_SENSOR_GYRO_FSR are defined in 'QxAutoMLUser.h': 
```
#include "QxAutoMLUser.h"
void NativelInitSensor(void)
{
    static bool senosr_initialized = false;
    if (senosr_initialized) {
        return;
    }
    senosr_initialized = true;
    
    /* init and enable accelerometer @& gyrometer */
#ifdef QXAUTOMLCONFIG_SENSOR_ENABLE_ACCEL
    BSP_MOTION_SENSOR_Init(IIS2DH_0, MOTION_ACCELERO);
    BSP_MOTION_SENSOR_SetOutputDataRate(IIS2DH_0, MOTION_ACCELERO, QXAUTOMLCONFIG_SENSOR_ACCEL_ODR);
    BSP_MOTION_SENSOR_SetFullScale(IIS2DH_0, MOTION_ACCELERO, QXAUTOMLCONFIG_SENSOR_ACCEL_FSR);
    
#endif

#ifdef QXAUTOMLCONFIG_SENSOR_ENABLE_GYRO

    BSP_MOTION_SENSOR_Init(ISM330DHCX_0, MOTION_GYRO);
    BSP_MOTION_SENSOR_SetOutputDataRate(ISM330DHCX_0, MOTION_GYRO, QXAUTOMLCONFIG_SENSOR_GYRO_ODR);
    BSP_MOTION_SENSOR_SetFullScale(ISM330DHCX_0, MOTION_GYRO, QXAUTOMLCONFIG_SENSOR_GYRO_FSR);

#endif
}
```

4. Native OS tick funtions
     `void NativeOSDelay(int msec)` provides a tick value in millisecond.
     `int NativeOSGetTick()` gets tick counter in millisecond unit.

 ### Run `int QxAutoMLWork()` in the your application
  After finished all of above steps, function `int QxAutoMLWork()` gets ready to run in any thread loop that you want to do the classification. 

```
void applicatioin_thread_loop()
{
    NativelInitSensor();
    
    while (1){
        int ClassificationResult;

        ClassificationResult = QxAutoMLWork();
        if (ClassificationResult) {
            BSP_LED_On(LED1);
      } else {
            BSP_LED_Off(LED1);
      }
    }
}
```

  Congratulations! the integration of AutoML static engine library is done, if everything runs okay, you should see the classification runs as good as what you see in WebUI's model LIVE test.
